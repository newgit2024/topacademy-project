Микросервисы:
Плюсы:
- Гибкость и масштабируемость. Микросервисы позволяют быстро и гибко развивать приложение, добавляя новые сервисы и масштабируя их отдельно друг от друга.
- Лучшая изоляция ошибок. Каждый сервис работает в своем собственном контексте, что позволяет изолировать ошибки и упрощает их поиск и исправление.
- Легкость внедрения новых технологий. Разработчики могут использовать различные технологии и языки программирования для каждого сервиса, что позволяет выбирать наиболее подходящие инструменты для решения конкретных задач.
  Минусы:
- Сложность управления. Управление множеством сервисов может быть сложным и требует высокой квалификации разработчиков.
- Усложнение интеграции. Интеграция между сервисами может быть сложной и требует дополнительных усилий.
- Высокая стоимость. Разработка и поддержка микросервисной архитектуры может быть дороже, чем разработка монолитного приложения.

Монолиты:
Плюсы:
- Простота управления. Монолитное приложение проще управлять, так как все компоненты находятся в одном месте.
- Простота интеграции. Интеграция компонентов в монолитном приложении проще, чем в микросервисной архитектуре.
- Более низкая стоимость. Разработка и поддержка монолитного приложения может быть дешевле, чем разработка микросервисной архитектуры.
  Минусы:
- Сложность масштабирования. Монолитное приложение сложнее масштабировать, так как все компоненты находятся в одном месте.
- Большая вероятность ошибок. Все компоненты находятся в одном месте, что может привести к большой вероятности ошибок и увеличению времени на их исправление.
- Ограниченность выбора технологий. В монолитном приложении разработчики ограничены выбором технологий и языков программирования.
###
1. API Gateway - паттерн, который предоставляет единую точку входа для клиентов приложения и обеспечивает маршрутизацию запросов к соответствующим микросервисам.
2. Service Registry - паттерн, который предоставляет централизованный реестр всех доступных микросервисов в системе и обеспечивает их динамическое обнаружение другими сервисами.
3. Circuit Breaker - паттерн, который предотвращает сбои в системе, обеспечивая контроль доступности микросервисов и автоматическое отключение недоступных сервисов.
4. Event Sourcing - паттерн, который используется для сохранения всех изменений состояния системы в виде событий, что обеспечивает возможность восстановления состояния системы в любой момент времени.
5. Saga - паттерн, который используется для управления транзакциями между несколькими микросервисами, обеспечивая атомарность операций и откат изменений в случае ошибок.

№№№
Для создания неизменяемого класса необходимо выполнить следующие шаги:

1. Объявить все поля класса как final.
2. Убедиться, что все поля класса инициализируются только в конструкторе.
3. Не предоставлять сеттеры для полей класса.
4. Если необходимо предоставить доступ к полям класса, то делать это только через геттеры, которые должны возвращать копии значений полей.


Пример неизменяемого класса:

public final class Person {
private final String name;
private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}


###
