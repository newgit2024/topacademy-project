###
**Стори-поинты (Story Points)** - это относительные единицы измерения сложности задач, используемые в методологии Agile, особенно в методологии Scrum. Они помогают оценивать сложность и объем работы, который необходим для выполнения определенной задачи или функциональности. Вместо прямого временного оценивания задач, как в часах или днях, используются стори-поинты для более гибкой и адаптивной оценки.

Принцип работы:

1. **Относительная оценка:** Стори-поинты представляют собой относительную оценку, где каждый стори-поинт имеет свой уровень сложности и объем работы. Например, можно выбрать стори-поинты: 1, 2, 3, 5, 8, 13 и т.д.

2. **Обсуждение и согласование:** Команда разработчиков собирается для обсуждения задачи и коллективно оценивает сложность, сравнивая ее с другими задачами, которые они ранее выполняли. Например, если задача "A" кажется более сложной, чем задача "B", то ей может быть присвоен более высокий стори-поинт.

3. **Фибоначчиева последовательность:** Часто используется последовательность Фибоначчи для стори-поинтов, так как она позволяет более точно выразить разницу в сложности между задачами.

4. **Коллективное решение:** Разработчики делятся своими мнениями о сложности задачи и договариваются о том, какой стори-поинт лучше всего подходит для данной задачи. Цель - достижение консенсуса в команде.

5. **Постепенная уточненная оценка:** С течением времени и опыта, команда может уточнять оценки стори-поинтов на основе фактического времени, потраченного на задачи, и понимания сложности.

Преимущества:

- **Относительная оценка:** Стори-поинты позволяют избежать проблем, связанных с прямым временным оцениванием, так как сложность работы может зависеть от множества факторов, включая опыт, знания и условия.
- **Объективное сравнение:** Команда может сравнивать задачи между собой на основе их сложности, а не времени, что улучшает точность оценки.
- **Гибкость и адаптивность:** Стори-поинты позволяют адаптироваться к изменениям и более гибко планировать работу.

Недостатки:

- **Субъективность:** Оценка стори-поинтов остается субъективной, так как она зависит от восприятия каждого члена команды.
- **Неоднозначность:** Перевод стори-поинтов в реальное время может быть непостоянным и привести к неопределенности при планировании.
- **Сложность конвертации:** Преобразование стори-поинтов в конкретное время может быть сложным и даже ошибочным.

Стори-поинты - это инструмент для более гибкой оценки задач в Agile-разработке, который позволяет команде лучше понимать объем работы и планировать проекты.
###
Конечно, вот примеры оптимистической и пессимистической блокировки в Hibernate:

**Оптимистическая блокировка**:
В оптимистической блокировке изменения данных не блокируют доступ других пользователей к данным. Вместо этого используется механизм версионирования, например, с помощью поля `@Version`.

```java
@Entity
public class Product {
    @Id
    @GeneratedValue
    private Long id;
    
    private String name;
    
    @Version
    private int version; // Поле версии
    
    // Геттеры, сеттеры и другие поля
}
```

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

Product product = session.get(Product.class, 1L);
product.setName("New Name");

tx.commit();
session.close();
```

**Пессимистическая блокировка**:
Пессимистическая блокировка предполагает блокировку данных на уровне базы данных для предотвращения конфликтов. Это часто достигается с использованием `LockMode`, например, `LockMode.PESSIMISTIC_WRITE` для блокировки на запись.

```java
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

Product product = session.get(Product.class, 1L, LockMode.PESSIMISTIC_WRITE);
product.setName("New Name");

tx.commit();
session.close();
```

Обратите внимание, что выбор между оптимистической и пессимистической блокировкой зависит от сценариев использования и требований вашего приложения. Оптимистическая блокировка чаще используется в ситуациях, когда конфликты между транзакциями редки, а пессимистическая блокировка - когда необходимо гарантировать целостность данных в ситуациях, когда изменения происходят часто.
###
Аннотация `@Autowired` в Spring позволяет автоматически внедрять зависимости в бины. Однако существует несколько потенциальных проблем, связанных с использованием `@Autowired`:

1. **Несколько кандидатов для инъекции:** Если в контейнере Spring есть несколько бинов, которые могут подходить для инъекции, может возникнуть неоднозначность. В этом случае Spring не сможет однозначно определить, какой бин следует инъецировать, и выбросит исключение.

2. **Неявная зависимость:** Использование `@Autowired` может привести к неявным зависимостям между компонентами, что усложняет понимание потока данных и влияния изменений на приложение.

3. **Сложное тестирование:** В юнит-тестах может быть сложно контролировать и подменять зависимости, инъецированные через `@Autowired`, что делает тестирование более сложным.

4. **Зависимость от конкретной реализации:** При использовании `@Autowired` ваш код будет зависеть от конкретной реализации бинов, что может усложнить замену одной реализации на другую или переиспользование кода в другом проекте.

5. **Отсутствие контроля над жизненным циклом:** Spring управляет жизненным циклом бинов, инъецированных через `@Autowired`. Это может привести к неожиданному поведению, если вы ожидали более точного контроля над их жизненным циклом.

Для решения этих проблем можно использовать альтернативные способы инъекции зависимостей, такие как конструкторы, сеттеры или Java Config, которые предоставляют более явное и контролируемое внедрение зависимостей. Также можно использовать аннотацию `@Qualifier`, чтобы явно указать, какой бин следует инъецировать в случае неоднозначности.
###
В контексте тестирования в Spring Framework существует две аннотации, связанные с созданием заглушек (mocks): `@Mock` и `@MockBean`. Обе аннотации предназначены для создания мок-объектов, но они используются в разных ситуациях и с разными целями.

1. **@Mock:**
    - `@Mock` является частью библиотеки Mockito, которая предоставляет возможности для создания мок-объектов и организации тестов.
    - Она используется для создания мок-объектов в юнит-тестах, которые не связаны напрямую с Spring-контейнером.
    - Моки, созданные с помощью `@Mock`, могут быть внедрены в тестируемый объект вручную, используя привычные для Mockito методы, например, `when()` и `thenReturn()`.

Пример использования `@Mock` в тесте с использованием Mockito:

```java
@RunWith(MockitoJUnitRunner.class)
public class MyServiceTest {

    @Mock
    private MyRepository mockRepository;

    @InjectMocks
    private MyService myService;

    @Test
    public void testSomeMethod() {
        when(mockRepository.getData()).thenReturn("Mocked Data");
        String result = myService.someMethod();
        assertEquals("Mocked Data", result);
    }
}
```

2. **@MockBean:**
    - `@MockBean` является частью Spring Test и предоставляет возможности для создания мок-бинов (мок-объектов), которые можно интегрировать в Spring-контекст и использовать в интеграционных тестах.
    - Она используется для замены реальных бинов в контексте Spring на мок-бины с целью управления поведением бинов во время интеграционного тестирования.
    - Мок-бины, созданные с помощью `@MockBean`, автоматически интегрируются в Spring-контекст и заменяют оригинальные бины во время выполнения тестов.

Пример использования `@MockBean` в интеграционном тесте с использованием Spring Test:

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class MyServiceIntegrationTest {

    @MockBean
    private MyRepository mockRepository;

    @Autowired
    private MyService myService;

    @Test
    public void testSomeMethod() {
        when(mockRepository.getData()).thenReturn("Mocked Data");
        String result = myService.someMethod();
        assertEquals("Mocked Data", result);
    }
}
```

Итак, основное отличие между `@Mock` и `@MockBean` заключается в том, что первая используется в юнит-тестах с Mockito для создания мок-объектов, а вторая - в интеграционных тестах с Spring Test для создания мок-бинов в контексте Spring.
###
По вашему описанию, видимо, вы хотите узнать о Spring Framework и аннотациях для работы с условиями и конфигурацией. В Spring существует несколько аннотаций для работы с условиями и конфигурацией в зависимости от условий. Вот некоторые из них:

1. **@Conditional:**
   Эта аннотация позволяет вам указать условие, при котором компонент будет создан. Вы можете определить свой класс, реализующий интерфейс `Condition`, который определит, должен ли компонент быть создан, исходя из определенного условия.

   Пример:
   ```java
   @Configuration
   @Conditional(MyCondition.class)
   public class MyConfig {
       // ...
   }
   ```

2. **@Profile:**
   Аннотация `@Profile` позволяет указать, когда бин или конфигурация должны быть активными в зависимости от указанного профиля.

   Пример:
   ```java
   @Component
   @Profile("development")
   public class DevComponent {
       // ...
   }
   ```

3. **@ConditionalOnProperty:**
   Эта аннотация позволяет включать или отключать бин в зависимости от значения определенного свойства в файле `application.properties` или `application.yml`.

   Пример:
   ```java
   @Component
   @ConditionalOnProperty(name = "myapp.feature.enabled", havingValue = "true")
   public class MyFeatureComponent {
       // ...
   }
   ```

4. **@ConditionalOnClass:**
   С помощью этой аннотации можно указать, что бин будет создан только в случае наличия определенного класса в класспасе.

   Пример:
   ```java
   @Configuration
   @ConditionalOnClass(name = "org.springframework.web.servlet.DispatcherServlet")
   public class MyWebConfig {
       // ...
   }
   ```

5. **@ConditionalOnMissingBean:**
   Аннотация `@ConditionalOnMissingBean` указывает, что бин будет создан только в случае отсутствия другого бина с заданным типом.

   Пример:
   ```java
   @Component
   @ConditionalOnMissingBean(MyService.class)
   public class DefaultService implements MyService {
       // ...
   }
   ```

Каждая из этих аннотаций позволяет гибко настраивать, какие компоненты и конфигурации должны быть созданы в зависимости от условий в приложении.
###
В Spring фреймворке нет классической реализации паттерна "двухфазный конструктор" в том виде, как он описан выше. Однако, Spring предоставляет механизмы для управления жизненным циклом объектов и их инициализацией. Давайте рассмотрим, как можно использовать Spring для обеспечения безопасной инициализации объектов.

1. **Constructor Injection (Внедрение через конструктор)**:

Spring рекомендует использовать внедрение зависимостей через конструктор. Это позволяет передать все необходимые параметры для инициализации объекта в момент его создания. Пример:

```java
@Service
public class MyService {
    private final DataService dataService;

    @Autowired
    public MyService(DataService dataService) {
        this.dataService = dataService;
    }

    // ...
}
```

2. **InitializingBean и DisposableBean**:

Spring предоставляет интерфейсы `InitializingBean` и `DisposableBean`, которые можно реализовать в своих бинах для определения методов, которые будут вызваны при инициализации и уничтожении бина соответственно. Однако, рекомендуется использовать аннотации `@PostConstruct` и `@PreDestroy` для тех же целей, так как они более читаемы и не привязывают ваши классы к Spring API:

```java
@Service
public class MyService {

    @PostConstruct
    public void init() {
        // Инициализация объекта
    }

    @PreDestroy
    public void cleanUp() {
        // Очистка ресурсов перед уничтожением бина
    }

    // ...
}
```

3. **Bean Initialization Callbacks**:

Spring позволяет определить пользовательские методы для инициализации и уничтожения бина, используя аннотации `@Bean` в конфигурационном классе:

```java
@Configuration
public class AppConfig {

    @Bean(initMethod = "init", destroyMethod = "cleanUp")
    public MyService myService() {
        return new MyService();
    }
}
```

4. **Фабричные методы и фабричные бины**:

Вы также можете использовать фабричные методы и бины для создания объектов с определенными параметрами:

```java
@Configuration
public class AppConfig {

    @Bean
    public MyService myService(DataService dataService) {
        return new MyService(dataService);
    }
}
```

В итоге, в Spring фреймворке подход к управлению жизненным циклом объектов может быть реализован через внедрение зависимостей, аннотации и методы, обеспечивая безопасную инициализацию и уничтожение бинов.
###
Класс `ApplicationEventPublisher` в Spring Framework предоставляет возможность публиковать события и уведомлять об этих событиях заинтересованные компоненты. Это является частью механизма Spring для обработки событий, который позволяет различным компонентам взаимодействовать между собой, но без прямой связи.

Пример использования класса `ApplicationEventPublisher` в Spring:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
public class MyService {

    private final ApplicationEventPublisher eventPublisher;

    @Autowired
    public MyService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    public void performSomeAction() {
        // Выполнение действий

        // Публикация события
        MyCustomEvent event = new MyCustomEvent(this, "Some data");
        eventPublisher.publishEvent(event);
    }
}
```

В данном примере класс `MyService` содержит `ApplicationEventPublisher`, который внедряется через конструктор. Метод `performSomeAction()` выполняет какие-либо действия и затем публикует пользовательское событие `MyCustomEvent`.

Для того чтобы обработать это событие, вы можете создать слушатель события:

```java
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class MyCustomEventListener implements ApplicationListener<MyCustomEvent> {

    @Override
    public void onApplicationEvent(MyCustomEvent event) {
        // Обработка события
        System.out.println("Received custom event: " + event.getData());
    }
}
```

События могут быть абсолютно любыми и могут быть использованы для обмена информацией между различными компонентами вашего приложения. Применения могут варьироваться от простой обработки уведомлений до более сложных механизмов синхронизации и взаимодействия между компонентами.

Классы событий, такие как `MyCustomEvent` в примере, обычно являются пользовательскими классами, которые наследуются от `ApplicationEvent`.
###
В Spring Framework термин "bean definition" (бин-определение) относится к метаданным, которые описывают, как создать и настроить экземпляр бина. Бин-определение содержит информацию о классе бина, его зависимостях, настройках и других свойствах.

Бин-определение может быть представлено различными способами:

1. **XML-конфигурация:** В более старых версиях Spring бины могли быть определены в XML-конфигурационных файлах. Пример бин-определения в XML:

```xml
<bean id="myBean" class="com.example.MyBean" />
```

2. **Аннотации:** В современных версиях Spring бины могут быть определены с использованием аннотаций, таких как `@Component`, `@Service`, `@Repository` и т.д. Пример аннотационного бин-определения:

```java
@Component
public class MyBean {
    // ...
}
```

3. **JavaConfig:** Бины также могут быть определены с использованием JavaConfig, то есть конфигурационных классов, помеченных аннотацией `@Configuration`. Пример бин-определения в JavaConfig:

```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```

Все эти способы определения бинов в Spring предоставляют метаданные, которые Spring Framework использует для создания, настройки и управления экземплярами бинов в контейнере. Бин-определения являются ключевой частью конфигурации Spring приложения, позволяя задавать, какие компоненты будут созданы и как они будут взаимодействовать между собой.
###
Аннотация `@Import` в Spring Framework используется для импорта конфигурационных классов или компонентов из других конфигураций в текущую конфигурацию. Это позволяет создавать более модульные и организованные конфигурации, а также объединять различные компоненты из разных мест в одном контексте.

Пример использования аннотации `@Import`:

Предположим, у нас есть два конфигурационных класса: `DatabaseConfig` и `MessagingConfig`, каждый из которых настраивает свою область функциональности.

```java
@Configuration
public class DatabaseConfig {
    // Конфигурация для базы данных
}
```

```java
@Configuration
public class MessagingConfig {
    // Конфигурация для мессенджинга
}
```

Мы можем импортировать эти конфигурации в главный конфигурационный класс:

```java
@Configuration
@Import({DatabaseConfig.class, MessagingConfig.class})
public class AppConfig {
    // Остальная конфигурация
}
```

Теперь в классе `AppConfig` будут доступны бины и настройки как из `DatabaseConfig`, так и из `MessagingConfig`. Это может быть полезно, если вы хотите объединить разные аспекты приложения, такие как база данных и мессенджинг, в одном контексте.

Аннотация `@Import` упрощает разделение функциональности и создание более модульной и структурированной конфигурации, что важно для поддержания чистоты кода и возможности повторного использования.
###
Создание собственного Spring Boot Starter'a - это способ упростить конфигурацию и использование определенного набора библиотек и компонентов в ваших проектах. Starter предоставляет преднастроенные зависимости, бины и конфигурации, которые можно легко интегрировать в приложение. Вот как это можно сделать:

1. **Создание проекта для Starter'a**:

   Создайте новый проект, используя средства сборки, такие как Maven или Gradle. Этот проект будет базовым для вашего Starter'a.

2. **Структура проекта**:

   Структура проекта может выглядеть следующим образом:

   ```
   your-starter/
   ├── src/
   │   ├── main/
   │   │   ├── java/
   │   │   │   └── com/
   │   │   │       └── yourpackage/
   │   │   │           ├── YourStarterAutoConfiguration.java
   │   │   │           └── YourStarterProperties.java
   │   │   └── resources/
   │   │       └── META-INF/
   │   │           └── spring.factories
   │   └── test/
   │       └── java/
   │           └── com/
   │               └── yourpackage/
   │                   └── YourStarterAutoConfigurationTest.java
   ├── pom.xml (или build.gradle)
   └── README.md
   ```

3. **Auto-Configuration класс**:

   В `YourStarterAutoConfiguration.java` вы определяете, какие бины и настройки будут предварительно настроены в Spring контексте, когда Starter будет подключен. Этот класс должен быть аннотирован `@Configuration` и `@ConditionalOnClass` (если Starter зависит от определенных классов).

   ```java
   package com.yourpackage;

   import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;

   @Configuration
   @ConditionalOnClass({YourClass.class})
   public class YourStarterAutoConfiguration {

       @Bean
       public YourBean yourBean() {
           return new YourBean();
       }

       // Другие бины и настройки
   }
   ```

4. **Конфигурационные свойства**:

   В `YourStarterProperties.java` вы определяете свойства, которые пользователь вашего Starter'a может настраивать в `application.properties` или `application.yml`.

   ```java
   package com.yourpackage;

   import org.springframework.boot.context.properties.ConfigurationProperties;

   @ConfigurationProperties("yourstarter")
   public class YourStarterProperties {
       private String property1;
       private int property2;

       // Геттеры и сеттеры
   }
   ```

5. **Файл `spring.factories`**:

   В `src/main/resources/META-INF` создайте файл `spring.factories`, в котором определите ваш Auto-Configuration класс.

   ```
   org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.yourpackage.YourStarterAutoConfiguration
   ```

6. **Тестирование**:

   Создайте тесты для вашего Starter'a, чтобы удостовериться, что настройки и бины работают, как ожидалось.

7. **Сборка и публикация**:

   Соберите ваш проект в JAR-файл. Вы можете опубликовать этот JAR-файл в репозитории Maven или Gradle для использования в ваших проектах.

После этого вы можете подключать ваш Starter к другим проектам и использовать предварительно настроенные бины и настройки без необходимости дублирования кода.
###
https://coderlessons.com/articles/java/rukovodstvo-po-annotatsiiam-spring-framework
###
Руководство по аннотациям Spring Framework
Июль 24, 2017
Язык программирования Java обеспечивал поддержку аннотаций с Java 5.0 и выше. Ведущие платформы Java быстро приняли аннотации, и Spring Framework начал использовать аннотации из версии 2.5. Благодаря тому, как они определены, аннотации предоставляют много контекста в их объявлении.


До аннотаций поведение Spring Framework в основном контролировалось с помощью конфигурации XML. Сегодня использование аннотаций предоставляет нам огромные возможности в настройке поведения Spring Framework.

В этой статье мы рассмотрим аннотации, доступные в Spring Framework.

Основные Spring Framework Аннотации
@Необходимые
Эта аннотация применяется к методам установки бинов. Рассмотрим сценарий, в котором вам нужно применить обязательное свойство. @Required Аннотацию указывает на то, что пострадавшее компонент должен быть заполнен во время конфигурации с требуемым свойством. В противном случае создается исключение типа  BeanInitializationException .

@Autowired
Эта аннотация применяется к полям, методам установки и конструкторам. В  @Autowired аннотации впрыскивает объект зависимости неявно.

Когда вы используете @Autowired поля и передаете значения для полей, используя имя свойства, Spring автоматически назначает поля с переданными значениями.


Вы даже можете использовать  @Autowired  частные объекты, как показано ниже. (Это очень плохая практика!)

public class Customer {
@Autowired                               
private Person person;                   
private int type;
}
Когда вы используете  @Autowired методы установки, Spring пытается выполнить это, набрав autowiring для этого метода. Вы указываете Spring, что оно должно инициировать это свойство, используя метод установки, в котором вы можете добавить свой собственный код, например, инициализировать любое другое свойство этим свойством.

public class Customer {                                                                                         
private Person person;
@Autowired                                                                                                      
public void setPerson (Person person) {
this.person=person;
}
}
Рассмотрим сценарий, в котором вам нужен экземпляр класса A, но вы не храните A в поле класса. Вы просто используете A для получения экземпляра B и сохраняете B в этом поле. В этом случае сеттер методом автопроводки подойдет вам лучше. У вас не будет неиспользуемых полей на уровне класса.

Когда вы используете  @Autowired конструктор, тогда внедрение конструктора происходит во время создания объекта. Он сообщает конструктору об автоматической передаче при использовании в качестве компонента. Здесь следует заметить, что только один конструктор из любого класса бинов может нести  @Autowired аннотацию.

@Component
public class Customer {
private Person person;
@Autowired
public Customer (Person person) {
this.person=person;
}
}
ПРИМЕЧАНИЕ. Начиная с весны 4.3,  @Autowired стало необязательным для классов с одним конструктором. В приведенном выше примере Spring по-прежнему внедрит экземпляр класса Person, если вы опустите  @Autowired аннотацию.

@Qualifier
Эта аннотация используется вместе с  @Autowired аннотацией. Когда вам нужно больше контроля над процессом внедрения зависимости,  @Qualifier можно использовать. @Qualifier может быть указано в отдельных аргументах конструктора или параметрах метода. Эта аннотация используется, чтобы избежать путаницы, которая возникает, когда вы создаете несколько бинов одного типа и хотите связать только один из них со свойством.

Рассмотрим пример, где интерфейс  BeanInterface реализуется двумя bean-компонентами, BeanB1 и BeanB2.

@Component
public class BeanB1 implements BeanInterface {
//
}
@Component
public class BeanB2 implements BeanInterface {
//
}
Теперь, если BeanA автоматически подключит этот интерфейс, Spring не будет знать, какую из двух реализаций внедрить.

Одним из решений этой проблемы является использование  @Qualifier аннотации.

@Component
public class BeanA {
@Autowired
@Qualifier("beanB2")
private IBean dependency;
...
}
С  @Qualifier добавленной аннотацией Spring теперь будет знать, какой bean-компонент нужно связать автоматически, а где  beanB2 имя BeanB2.

@Configuration
Эта аннотация используется для классов, которые определяют bean-компоненты. @Configuration является аналогом файла конфигурации XML — он настраивается с использованием классов Java. Класс Java с  @Configuration пометкой сам по себе является конфигурацией и будет иметь методы для создания экземпляров и настройки зависимостей.

Вот пример:

@Configuartion
public class DataConfig {
@Bean
public DataSource source() {
DataSource source = new OracleDataSource();
source.setURL();
source.setUser();
return source;
}
@Bean
public PlatformTransactionManager manager() {
PlatformTransactionManager manager = new BasicDataSourceTransactionManager();
manager.setDataSource(source());
return manager;
}
}
@ComponentScan
Эта аннотация используется вместе с  @Configuration аннотацией, чтобы Spring мог узнать, какие пакеты сканируются для аннотированных компонентов. @ComponentScan также используется для указания использования базовых пакетов  basePackageClasses или  basePackage атрибутов для сканирования. Если конкретные пакеты не определены, сканирование будет выполняться из пакета класса, который объявляет эту аннотацию.

@Bean
Эта аннотация используется на уровне метода. В  @Bean аннотации работа с  @Configuration создать пружину бобы. Как упоминалось ранее,  @Configuration  будут иметь методы для создания экземпляров и настройки зависимостей. Такие методы будут аннотированы  @Bean. Метод, аннотированный этой аннотацией, работает как идентификатор компонента, а также создает и возвращает фактический компонент.

Вот пример:

@Configuration
public class AppConfig {
@Bean
public Person person() {
return new Person(address());
}
@Bean
public Address address() {
return new Address();
}
}
@Lazy
Эта аннотация используется для классов компонентов. По умолчанию все автосвязные зависимости создаются и настраиваются при запуске. Но если вы хотите лениво инициализировать бин, вы можете использовать  @Lazy аннотацию над классом. Это означает, что bean-компонент будет создан и инициализирован только при первом запросе. Вы также можете использовать эту аннотацию на  @Configuration занятиях. Это указывает на то, что все  @Bean методы в пределах этого  @Configuration должны быть лениво инициализированы.

@Значение
Эта аннотация используется на уровнях поля, параметра конструктора и параметра метода. @Value  Аннотации указывает выражение на значение по умолчанию для поля или параметра , чтобы инициализировать свойство с. Так как @Autowired аннотация говорит Spring, чтобы внедрить объект в другой при загрузке контекста приложения, вы также можете использовать @Value аннотацию для вставки значений из файла свойств в атрибут компонента. Он поддерживает заполнители # {…} и $ {…} .

Spring Framework Аннотации стереотипов
@Компонент
Эта аннотация используется в классах для обозначения компонента Spring. В @Component аннотации помечает класс Java , как боб или компонента , так что механизм компонент сканирования весны может добавить его в контекст приложения.

@Controller
@Controller Аннотаций используется для указания класса является контроллером Спринг. Эта аннотация может использоваться для идентификации контроллеров для Spring MVC или Spring WebFlux.

@Обслуживание
Эта аннотация используется в классе. @Service помечает класс Java, который выполняет некоторую услугу, такую ​​как выполнение бизнес-логики, выполнение вычислений и вызов внешних API. Эта аннотация является специализированной формой  @Component аннотации, предназначенной для использования на сервисном уровне.

@Repository
Эта аннотация используется в классах Java, которые напрямую обращаются к базе данных. В  @Repository аннотации работает как маркер для любого класса , который выполняет роль хранилища или доступ к данным объекта.

Эта аннотация имеет функцию автоматического перевода. Например, когда возникает исключение в   @Repository, существует обработчик для этого исключения, и нет необходимости добавлять блок try-catch.

Spring Boot Annotations
@EnableAutoConfiguration
Эта аннотация обычно помещается в основной класс приложения. @EnableAutoConfiguration  Аннотацию неявно определяет базу «поиск пакетов». Эта аннотация говорит Spring Boot начинать добавление bean-компонентов на основе настроек пути к классам, других bean-компонентов и различных настроек свойств.

@SpringBootApplication
Эта аннотация используется в классе приложения при настройке проекта Spring Boot. Класс, помеченный знаком,  @SpringBootApplication  должен храниться в базовом пакете. Единственное, что  @SpringBootApplication делает, — это компонентное сканирование. Но он будет сканировать только свои подпакеты. Например, если вы поместите аннотированный класс  @SpringBootApplication в com.example, он  @SpringBootApplication будет сканировать все его подпакеты, такие как com.example.a, com.example.b и com.example.ax.

Это  @SpringBootApplication  удобная аннотация, которая добавляет все следующее:

@Configuration
@EnableAutoConfiguration
@ComponentScan
Spring MVC и REST Аннотации
@Controller
Эта аннотация используется в классах Java, которые играют роль контроллера в вашем приложении.  @Controller Аннотаций позволяет автоопределение классов компонентов в пути к классам и автоматическим регистрации бин для них. Чтобы включить автоматическое обнаружение таких аннотированных контроллеров, вы можете добавить компонентное сканирование в вашу конфигурацию. Класс Java с комментариями  @Controller  способен обрабатывать несколько сопоставлений запросов.

Эта аннотация может использоваться с Spring MVC и Spring WebFlux.

@RequestMapping
Эта аннотация используется как на уровне класса, так и на уровне метода.  @RequestMapping  Аннотаций используется для отображения веб — запросов на конкретные классы обработчиков и обработчиков методов. Когда  @RequestMapping используется на уровне класса, он создает базовый URI, для которого будет использоваться контроллер. Когда эта аннотация используется для методов, она выдаст вам URI, для которого будут выполняться методы-обработчики. Отсюда можно сделать вывод, что сопоставление запросов на уровне класса останется прежним, тогда как у каждого метода-обработчика будет свое сопоставление запросов.

Иногда вам может потребоваться выполнить различные операции в зависимости от используемого метода HTTP, даже если URI запроса может оставаться прежним. В таких ситуациях вы можете использовать атрибут  @RequestMapping метода со значением метода HTTP, чтобы сузить методы HTTP для вызова методов вашего класса.

Вот базовый пример того, как работает контроллер вместе с отображениями запросов:

@Controller
@RequestMapping("/welcome")
public class WelcomeController {
@RequestMapping(method = RequestMethod.GET)
public String welcomeAll() {
return "welcome all";
}
}
В этом примере  метод /welcome обрабатывает  только запросы GET welcomeAll().

Эта аннотация также может использоваться с Spring MVC и Spring WebFlux.

@RequestMapping Аннотация очень универсальна. Пожалуйста, смотрите мой подробный пост о сопоставлении запросов здесь .

@CookieValue
Эта аннотация используется на уровне параметров метода. @CookieValue  используется в качестве аргумента метода отображения запроса. Файл cookie HTTP связан с  @CookieValue параметром для данного имени файла cookie. Эта аннотация используется в методе, аннотированном с помощью   @RequestMapping.
Давайте рассмотрим, что следующее значение cookie получено с HTTP-запросом

JSESSIONID=418AB76CD83EF94U85YD34W

Чтобы получить значение cookie, используйте @CookieValue следующим образом:

@ReuestMapping("/cookieValue")
public void getCookieValue(@CookieValue "JSESSIONID" String cookie){
}
@CrossOrigin
Эта аннотация используется как на уровне класса, так и на уровне метода для разрешения запросов между источниками. Во многих случаях хост, обслуживающий JavaScript, будет отличаться от хоста, обслуживающего данные. В таком случае кросс-ресурсное совместное использование ресурсов (CORS) обеспечивает междоменную связь. Чтобы включить эту связь, вам просто нужно добавить  @CrossOrigin  аннотацию.

По умолчанию  @CrossOrigin аннотация допускает все происхождение, все заголовки, методы HTTP, указанные в  @RequestMapping аннотации, и maxAge 30 мин. Вы можете настроить поведение, указав соответствующие значения атрибута.

Пример использования  @CrossOrigin на уровне методов контроллера и обработчика приведен ниже:

@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin(origins = "http://example.com")
    @RequestMapping("/message")
    public Message getMessage() {
        // ...
    }

    @RequestMapping("/note")
    public Note getNote() {
        // ...
    }
}
В этом примере, как  getExample() и  getNote() методы будут иметь MaxAge 3600 секунд. Кроме того,   getExample() будут разрешены только запросы о происхождении с сайта http://example.com, а  getNote()  запросы всех источников — со всех узлов.

Составленные варианты @RequestMapping
Spring Framework 4.3 представил следующие варианты @RequestMapping аннотаций на уровне методов,  чтобы лучше выразить семантику аннотированных методов. Использование этих аннотаций стало стандартным способом определения конечных точек. Они действуют как обертки для  @RequestMapping.

Эти аннотации могут использоваться с Spring MVC и Spring WebFlux.

@GetMapping
Эта аннотация используется для отображения запросов HTTP GET на определенные методы-обработчики. @GetMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.GET).

@PostMapping
Эта аннотация используется для отображения запросов HTTP POST на определенные методы-обработчики. @PostMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.POST).

@PutMapping
Эта аннотация используется для отображения запросов HTTP PUT на определенные методы-обработчики. @PutMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.PUT).

@PatchMapping
Эта аннотация используется для отображения запросов HTTP PATCH на определенные методы-обработчики. @PatchMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.PATCH).

@DeleteMapping
Эта аннотация используется для отображения запросов HTTP DELETE на определенные методы-обработчики. @DeleteMapping это составная аннотация, которая действует как ярлык для   @RequestMapping(method = RequestMethod.DELETE).

@ExceptionHandler
Эта аннотация используется на уровнях метода для обработки исключений на уровне контроллера. @ExceptionHandler Аннотаций используется для определения класса исключения он будет ловить. Вы можете использовать эту аннотацию для методов, которые должны вызываться для обработки исключения. Эти  @ExceptionHandler значения могут быть установлены в массив типов исключений. Если выдается исключение, которое соответствует одному из типов в списке, то @ExceptionHandler будет вызван метод, аннотированный с сопоставлением  .

@InitBinder
Эта аннотация является аннотацией уровня метода, которая играет роль идентификации методов, которые инициализируют -a  WebDataBinder ,  DataBinder который связывает параметр запроса с объектами JavaBean. Чтобы настроить привязку данных параметров запроса, вы можете использовать  @InitBinder аннотированные методы в нашем контроллере. Методы, отмеченные как,  @InitBinder включают все типы аргументов, которые поддерживаются методами-обработчиками.

В  @InitBinder аннотированные методы будут вызываться для каждого запроса HTTP , если не указать значение элемента этой аннотации. Элементом value может быть одно или несколько имен форм или параметров запроса, к которым применяется метод привязки init.

@Mappings и @Mapping
Эта аннотация используется на полях. @Mapping Аннотаций является мета-аннотаций , что указывает на веб — отображение аннотацию. При отображении разных имен полей необходимо настроить исходное поле на его целевое поле, и для этого необходимо добавить  @Mappings аннотацию. Эта аннотация принимает массив  @Mapping с исходными и целевыми полями.

@MatrixVariable
Эта аннотация используется для аннотирования аргументов метода обработчика запросов, чтобы Spring мог внедрить соответствующие биты матричного URI. Матричные переменные могут появляться в любом сегменте, каждый из которых разделен точкой с запятой. Если URL-адрес содержит матричные переменные, шаблон отображения запроса должен представлять их с помощью шаблона URI. @MatrixVariable Аннотацию гарантирует , что запрос соответствует с правильным матричным переменной URI.

@PathVariable
Эта аннотация используется для аннотирования аргументов метода обработчика запроса. @RequestMapping Аннотации могут быть использованы для обработки динамических изменений в URI , где определенное значение URI , действует в качестве параметра. Вы можете указать этот параметр с помощью регулярного выражения. @PathVariable Аннотации могут быть использованы для объявления этого параметра.

@RequestAttribute
Эта аннотация используется для привязки атрибута запроса к параметру метода обработчика. Spring получает значение именованного атрибута, чтобы заполнить параметр, отмеченный @RequestAttribute. Хотя  @RequestParamannotation используется для связывания значений параметров из строки запроса,  @RequestAttribute  используется для доступа к объектам, которые были заполнены на стороне сервера.

@RequestBody
Эта аннотация используется для аннотирования аргументов метода обработчика запроса. @RequestBody Аннотации указывает на то, что параметр метод должен быть связан с величиной тела запроса HTTP. HttpMessageConveter Отвечает за преобразование из сообщения запроса HTTP на объект.

@RequestHeader
Эта аннотация используется для аннотирования аргументов метода обработчика запроса. @RequestHeader Аннотаций используется для отображения параметра контроллера к значению заголовка запроса. Когда Spring отображает запрос,  @RequestHeader проверяет заголовок с именем, указанным в аннотации, и связывает его значение с параметром метода-обработчика. Эта аннотация поможет вам получить подробности заголовка в классе контроллера.

@RequestParam
Эта аннотация используется для аннотирования аргументов метода обработчика запроса. Иногда вы получаете параметры в URL запроса, в основном в запросах GET. В этом случае, наряду с  @RequestMapping аннотацией, вы можете использовать  @RequestParam аннотацию, чтобы получить параметр URL и сопоставить его с аргументом метода. @RequestParam Аннотаций используется для связывания параметров запроса с параметром метода в контроллере.

@RequestPart
Эта аннотация используется для аннотирования аргументов метода обработчика запроса. @RequestPart Аннотаций может быть использован вместо  того @RequestParam чтобы получить содержание конкретного многоголосных и привязать его к аргументу методы аннотации   @RequestPart. Эта аннотация учитывает заголовок «Content-Type» в составной части (часть запроса).

@ResponseBody
Эта аннотация используется для аннотирования методов обработчика запросов. @ResponseBody Аннотация похожа на  @RequestBody аннотацию. @ResponseBody Аннотацию указывает на то, что тип результата должен быть записан прямо в теле ответа в любом формате , вы указываете , как JSON или XML. Spring преобразует возвращаемый объект в тело ответа, используя  HttpMessageConveter.

@ResponseStatus
Эта аннотация используется для методов и классов исключений. @ResponseStatus помечает метод или класс исключений кодом состояния и причиной, которая должна быть возвращена. Когда вызывается метод-обработчик, для кода состояния устанавливается HTTP-ответ, который переопределяет информацию о состоянии, предоставленную любыми другими средствами. Класс контроллера также может быть аннотирован   @ResponseStatus, который затем наследуется всеми  @RequestMapping методами.

@ControllerAdvice
Эта аннотация применяется на уровне класса. Как объяснялось ранее, для каждого контроллера вы можете использовать  @ExceptionHandler метод, который будет вызываться при возникновении данного исключения. Но это обрабатывает только те исключения, которые происходят в контроллере, в котором он определен. Чтобы преодолеть эту проблему, теперь вы можете использовать  @ControllerAdvice аннотацию. Это примечание используется для определения @ExceptionHandler, @InitBinderи  @ModelAttribute методы , которые применяются ко всем  @RequestMapping методам. Таким образом, если вы определите  @ExceptionHandler аннотацию для метода в   @ControllerAdvice классе, она будет применена ко всем контроллерам.

@RestController
Эта аннотация используется на уровне класса. В  @RestController аннотации класс исполняется в качестве контроллера , где каждый метод возвращает объект домена вместо зрения. Аннотируя класс этой аннотацией, вам больше не нужно добавлять  @ResponseBody все  RequestMapping методы. Это означает, что вы больше не используете средства разрешения представления или не отправляете HTML в ответ. Вы просто отправляете объект домена в виде HTTP-ответа в формате, понятном потребителям, например JSON.

@RestController  это удобная аннотация, которая сочетает в себе  @Controller и   @ResponseBody.

@RestControllerAdvice
Эта аннотация применяется к классам Java. @RestControllerAdvice это удобная аннотация, которая сочетает в себе  @ControllerAdvice и @ResponseBody. Эта аннотация используется вместе с  @ExceptionHandler аннотацией для обработки исключений, возникающих в контроллере.

@SessionAttribute
Эта аннотация используется на уровне параметров метода. @SessionAttribute Аннотаций используется для связывания параметра метода в атрибут сеанса. Эта аннотация обеспечивает удобный доступ к существующим или постоянным атрибутам сеанса.

@SessionAttributes
Эта аннотация применяется на уровне типа для определенного обработчика. @SessionAtrributes Аннотаций используется , когда вы хотите добавить JavaBean объекта в сессию. Это используется, когда вы хотите сохранить объект в сеансе на короткое время. @SessionAttributes используется в сочетании с @ModelAttribute.

Рассмотрим этот пример:

@ModelAttribute("person")
public Person getPerson() {}
// within the same controller as above snippet
@Controller
@SeesionAttributes(value = "person", types = {
Person.class
})
public class PersonController {}
@ModelAttribute Имя присваивается в  @SessionAttributes качестве значения. @SessionAttributes Состоит из двух элементов. Элемент value — это имя сеанса в модели, а элемент types — это тип атрибутов сеанса в модели.

Spring Cloud Аннотации
@EnableConfigServer
Эта аннотация используется на уровне класса. При разработке проекта с несколькими службами вам необходимо иметь централизованный и простой способ настройки и извлечения конфигураций всех служб, которые вы собираетесь разрабатывать. Одним из преимуществ использования централизованного сервера конфигурации является то, что вам не нужно нести бремя запоминания того, где каждая конфигурация распределена по нескольким и распределенным компонентам.

Вы можете использовать @EnableConfigServer аннотацию Spring Cloud  для запуска сервера конфигурации, с которым могут общаться другие приложения.

@EnableEurekaServer
Эта аннотация применяется к классам Java. Одна из проблем, с которой вы можете столкнуться при декомпозиции вашего приложения на микросервисы, заключается в том, что каждому сервису становится трудно узнать адрес каждого другого сервиса, от которого он зависит. Приходит служба обнаружения, которая отвечает за отслеживание местоположения всех других микросервисов.

Eureka от Netflix является реализацией сервера обнаружения, а интеграция обеспечивается Spring Boot. Spring Boot упростил проектирование сервера Eureka, просто пометив начальный класс с помощью   @EnableEurekaServer.

@EnableDiscoveryClient
Эта аннотация применяется к классам Java. Чтобы указать любому приложению регистрироваться в Eureka, вам просто нужно добавить  @EnableDiscoveryClient аннотацию к точке входа приложения. Приложение, которое теперь зарегистрировано в Eureka, использует абстракцию клиента Spring Cloud Discovery для опроса реестра для своего собственного хоста и порта.

@EnableCircuitBreaker
Эта аннотация применяется к классам Java, которые могут действовать как прерыватель цепи. Схема автоматического выключателя может позволить микросервису продолжать работу при сбое связанной службы, предотвращая каскадный сбой. Это также дает сбойному сервису время для восстановления.

Класс с пометкой  @EnableCircuitBreaker  будет контролировать, размыкать и замыкать автоматический выключатель.

@HystrixCommand
Эта аннотация используется на уровне метода. Библиотека Hyfrix от Netflix обеспечивает реализацию шаблона прерывателя цепи. Когда вы применяете автоматический выключатель к методу, Hystrix отслеживает сбои метода. Как только сбои нарастают до порогового значения, Hystrix открывает канал, так что последующие вызовы также не срабатывают. Теперь Hystrix перенаправляет вызовы метода, и они передаются указанным резервным методам.

Hystrix ищет любой метод, аннотированный  @HystrixCommand аннотацией, и помещает его в прокси-сервер, подключенный к автоматическому выключателю, чтобы Hystrix мог отслеживать его.

Рассмотрим следующий пример:

@Service
public class BookService {
private final RestTemplate restTemplate;
public BookService(RestTemplate rest) {
this.restTemplate = rest;
}
@HystrixCommand(fallbackMethod = "newList") public String bookList() {
URI uri = URI.create("http://localhost:8081/recommended");
return this.restTemplate.getForObject(uri, String.class);
}
public String newList() {
return "Cloud native Java";
}
}
Здесь  @HystrixCommand применяется оригинальный метод   bookList(). У  @HystrixCommand  аннотации есть  newList запасной метод. Поэтому, по какой-то причине, если Hystrix откроет канал   bookList(), у вас будет список заполненных книг, готовый для пользователей.

Spring Framework DataAccess Аннотации
@Transactional
Эта аннотация помещается перед определением интерфейса, методом на интерфейсе, определением класса или открытым методом на классе. Простого присутствия  @Transactional недостаточно для активации транзакционного поведения. Это  @Transactional просто метаданные, которые могут использоваться некоторой инфраструктурой времени выполнения. Эта инфраструктура использует метаданные для настройки соответствующих компонентов с поведением транзакций.

Аннотация также поддерживает конфигурацию, такую ​​как:

Тип распространения транзакции
Уровень изоляции транзакции
Тайм-аут для операции, завернутой транзакцией
Флаг только для чтения — подсказка поставщику постоянства, что транзакция должна быть только для чтения. Правила отката для транзакции.
Аннотации на основе кэша
@Cacheable
Эта аннотация используется для методов. Самый простой способ включить поведение кеша для метода — это пометить его  @Cacheable и параметризировать его именем кеша, в котором будут храниться результаты.

@Cacheable("addresses")
public String getAddress(Book book){...}
В приведенном выше фрагменте метод  getAddress связан с кешем с именами адресов. Каждый раз, когда вызывается метод, кэш проверяется, чтобы увидеть, был ли вызов уже выполнен и не должен повторяться.

@CachePut
Эта аннотация используется для методов. Всякий раз, когда вам нужно обновить кэш, не мешая выполнению метода, вы можете использовать  @CachePut  аннотацию. То есть метод всегда будет выполняться, а результат кэшируется.

@CachePut("addresses")
public String getAddress(Book book){...}
Использование  @CachePut и @Cacheable использование одного и  того же метода категорически не рекомендуется, поскольку первый вызывает выполнение для выполнения обновления кэша, а последний вызывает пропуск метода с использованием кэша.

@CacheEvict
Эта аннотация используется для методов. Дело не в том, что вы всегда хотите заполнять кеш все большим количеством данных. Иногда вам может понадобиться удалить некоторые данные из кэша, чтобы вы могли заполнить кэш некоторыми новыми значениями. В таком случае используйте  @CacheEvict аннотацию.

@CacheEvict(value="addresses", allEntries="true")
public String getAddress(Book book){...}
Здесь, дополнительный элемент,  allEntriesиспользуется вместе с именем кэша, который должен быть очищен. Он имеет значение true, поэтому он очищает все значения и готовится к хранению новых данных.

@CacheConfig
Эта аннотация является аннотацией на уровне класса. @CacheConfig Аннотаций позволяет упростить некоторые сведения о кэш — памяти на одном месте. Размещение этой аннотации в классе не включает никаких операций кэширования. Это позволяет хранить конфигурацию кеша на уровне класса, чтобы вам не приходилось объявлять что-либо несколько раз.

Выполнение задач и планирование аннотаций
@Запланированное
Эта аннотация является аннотацией уровня метода. @Scheduled Аннотаций используется на методах наряду с метаданными запуска. Метод с  @Scheduled должен иметь возвращаемый тип void и не должен принимать никаких параметров.

Существуют разные способы использования  @Scheduled аннотации:

@Scheduled(fixedDelay=5000)
public void doSomething() {
// something that should execute periodically   
}
В этом случае продолжительность между окончанием последнего выполнения и началом следующего выполнения является фиксированной. Задачи всегда ждут окончания предыдущего.

@Scheduled(fixedRate=5000)
public void doSomething() {
// something that should execute periodically
}
В этом случае начало выполнения задачи не ожидает завершения предыдущего выполнения.

@Scheduled(initialDelay=1000,fixedRate=5000)
public void doSomething() {
// something that should execute periodically after an initial delay  
}
Задание сначала выполняется с задержкой, а затем продолжается с указанной фиксированной скоростью.

@Async
Эта аннотация используется для методов для выполнения каждого метода в отдельном потоке. @Async Аннотаций предусмотрен на методе , так что вызов этого метода будет происходить асинхронно. В отличие от методов, помеченных как @Scheduled, методы, помеченные как,  @Async могут принимать аргументы. Они будут вызываться обычным способом вызывающими во время выполнения, а не по запланированной задаче.

@Async может использоваться как с пустыми методами возвращаемого типа, так и с методами, возвращающими значение. Однако методы с возвращаемыми значениями должны иметь возвращаемое значение типа Future.

Spring Framework Аннотации для тестирования
@BootstrapWith
Эта аннотация является аннотацией на уровне класса. @BootstrapWith  Аннотаций используется для настройки , как Spring Framework TestContext загрузился. Эта аннотация используется в качестве метаданных для создания пользовательских аннотаций и уменьшения дублирования конфигурации в наборе тестов.

@ContextConfiguration
Эта аннотация представляет собой аннотацию на уровне класса, которая определяет метаданные, используемые для определения, какие файлы конфигурации использовать для загрузки  ApplicationContext теста. Более конкретно,  @ContextConfiguration  объявляет аннотированные классы, которые будут использоваться для загрузки контекста. Вы также можете указать Spring, где найти файл.

@ContextConfiguration(locations={"example/test-context.xml", loader = Custom ContextLoader.class})
@WebAppConfiguration
Эта аннотация является аннотацией на уровне класса. @WebAppConfiguration  Используется для объявления о том , что  ApplicationContext загружен для испытания интеграции должно быть  WebApplicationContext. Эта аннотация используется для создания веб-версии контекста приложения. Важно отметить, что эта аннотация должна использоваться с  @ContextConfiguration  аннотацией. Путь к корню веб-приложения по умолчанию — src / main / webapp . Вы можете переопределить его, передав другой путь к <span class = «theme: classic lang: default decode: true crayon-inline»> @ WebAppConfiguration.

@Timed
Эта аннотация используется для методов. @Timed Аннотации указывает на то, что аннотированный метод испытания должен завершить свое выполнение в определенный период времени (в миллисекундах). Если выполнение превышает указанное время в аннотации, тест не пройден.

@Timed(millis=10000)
public void testLongRunningProcess() {  ... }
В этом примере тест не пройден, если он превышает 10 секунд выполнения.

@Повторение
Эта аннотация используется в методах испытаний. Если вы хотите запустить тестовый метод несколько раз подряд автоматически, вы можете использовать  @Repeat аннотацию. Количество раз, которое метод испытания должен быть выполнен, указано в аннотации.

@Repeat(10)
@Test
public void testProcessRepeatedly() {  ... }
В этом примере тест будет выполнен 10 раз.

@Commit
Эту аннотацию можно использовать как аннотацию как на уровне класса, так и на уровне метода. После выполнения тестового метода транзакция транзакционного метода может быть зафиксирована с использованием  @Commit аннотации. Эта аннотация явно передает цель кода. При использовании на уровне класса эта аннотация определяет фиксацию для всех методов тестирования в классе. Когда объявляется как аннотация уровня метода,  @Commit указывает фиксацию для определенных методов тестирования, переопределяющих фиксацию уровня класса.

@RollBack
Эта аннотация может использоваться как аннотация как на уровне класса, так и на уровне метода. @RollBack Аннотаций указывает , является ли транзакция транзакционной метода испытаний должен быть произведен откат после завершения проверки его исполнения. Если это правда,   @Rollback(true)транзакция откатывается. В противном случае транзакция совершается. @Commit  используется вместо   @RollBack(false).

При использовании на уровне класса эта аннотация определяет откат для всех методов тестирования в классе.

Когда объявляется как аннотация уровня метода,   @RollBack указывает откат для определенных методов тестирования, переопределяя семантику отката на уровне класса.

@DirtiesContext
Эта аннотация используется как аннотация как на уровне класса, так и на уровне метода. @DirtiesContext  указывает на то, что пружина  ApplicationContext была каким-либо образом изменена или повреждена и должна быть закрыта. Это вызовет перезагрузку контекста перед выполнением следующего теста. ApplicationContext помечается как грязный до или после любого такого аннотированного метода, а также до или после текущего класса тестирования.

В @DirtiesContext аннотации опоры   BEFORE_METHOD,   BEFORE_CLASSи  BEFORE_EACH_TEST_METHOD  режимы для закрытия  ApplicationContext перед тестом.

ПРИМЕЧАНИЕ . Избегайте чрезмерного использования этой аннотации. Это дорогостоящая операция, и в случае злоупотребления она может реально замедлить ваш набор тестов.

@BeforeTransaction
Эта аннотация используется для аннотирования пустых методов в тестовом классе. @BeforeTransaction  аннотированные методы указывают, что они должны быть выполнены до начала выполнения любой транзакции. Это означает, что метод, отмеченный с помощью,  @BeforeTransaction  должен быть выполнен до того, как какой-либо метод, отмеченный как   @Transactional.

@AfterTransaction
Эта аннотация используется для аннотирования пустых методов в тестовом классе. @AfterTransaction аннотированные методы указывают, что они должны быть выполнены после завершения транзакции для методов тестирования. Это означает, что метод, отмеченный с помощью,  @AfterTransaction  должен выполняться после метода, отмеченного с помощью   @Transactional.

@sql
Эта аннотация может быть объявлена ​​в тестовом классе или тестовом методе для запуска сценариев SQL для базы данных. @Sql  Аннотацию настраивает путь ресурсов для сценариев SQL , которые должны быть выполнены по отношению к данной базе данных либо до , либо после тестового метода интегрирования. Когда  @Sql используется на уровне метода, он переопределяет любой  @Sqldefined в уровне класса.

@SqlConfig
Эта аннотация используется вместе с  @Sql аннотацией. @SqlConfig Аннотаций определяет метаданные , которые используются для определения того, как анализировать и выполнять сценарии SQL , настроенные с помощью  @Sql  аннотаций. При использовании на уровне класса эта аннотация служит глобальной конфигурацией для всех сценариев SQL в тестовом классе. Но при использовании напрямую с атрибутом config   @Sql, он  @SqlConfig служит локальной конфигурацией для объявленных сценариев SQL.

@SqlGroup
Эта аннотация используется для методов. @SqlGroup Аннотаций представляет собой контейнер аннотации , который может содержать несколько  @Sql аннотаций. Эта аннотация может объявлять вложенные  @Sql аннотации.
Кроме того,  @SqlGroup используется в качестве метааннотации для создания пользовательских составных аннотаций. Эта аннотация также может использоваться вместе с повторяемыми аннотациями, где она  @Sql может быть объявлена ​​несколько раз для одного и того же метода или класса.

@SpringBootTest
Эта аннотация используется для запуска контекста Spring для интеграционных тестов. Это откроет полный контекст автоконфигурации.

@DataJpaTest
@DataJpaTest Аннотаций только обеспечивает необходимую автоконфигурацию для тестирования Spring Data JPA с использованием базы данных в оперативной памяти , такие как H2.

Эта аннотация используется вместо @SpringBootTest.

@DataMongoTest
Это  @DataMongoTest обеспечит минимальную автоконфигурацию и встроенную MongoDB для запуска интеграционных тестов с Spring Data MongoDB.

@WebMVCTest
Это  @WebMVCTest вызовет фиктивный контекст сервлета для тестирования уровня MVC. Сервисы и компоненты не загружаются в контекст. Чтобы предоставить эти зависимости для тестирования,  @MockBean  обычно используется аннотация.

@AutoConfigureMockMVC
@AutoConfigureMockMVC Аннотаций работает очень похоже на  @WebMVCTest аннотацию, но запускается полная весна загрузки контекста.

@MockBean
Создает и внедряет Mockito Mock для данной зависимости.

@JsonTest
Ограничит автоматическую настройку Spring Boot компонентами, относящимися к обработке JSON.

Это аннотации также автоконфигурирования экземпляра JacksonTester или GsonTester .

@TestPropertySource
Аннотация на уровне класса, используемая для указания источников свойств для тестового класса.
###
###
###
###
###
###
###
###
###
###
###
###
###