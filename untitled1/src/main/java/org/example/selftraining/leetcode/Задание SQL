Задание SQL 
Дано: 
Склад ( таблица warehouse), товары ( таблица item) и связанная таблица товары на складе ( таблица warehouse_item). 
Необходимо найти на каждом складе категорию товара, у которой общая стоимость товаров на складе находится на 3 месте. 
Места распределяются по общей стоимости товаров одной категории на одном складе, где 1 место- это максимальная сумма товаров одной категории в рамках одного склада. 
Вывести название склада, название категории и общую стоимость товаров данной категории на складе. 
Например из списка 
1. склад 1 категория 1 5000 
2. склад 1 категория 2 5000 
5. склад 1 категория 3 3008 
4. склад 1 категория 4 3008 
5. склад 1 категория 5 1008 
6. склад 1 категория 6 1088 
7. склад 2 категория 1 5008 
3. склад 2 категория 2 4668 
9. склад 2 категория 3 3000 
10. склад 2 категория 4 2000 
11. склад 2 категория 5 1000 
12. склад 2 категория 6 1000
ChatGPT


Для решения этой задачи вы можете использовать SQL-запрос с использованием оконных функций (window functions) для определения места каждой категории товара на складе в зависимости от общей стоимости товаров этой категории на складе. Затем вы можете выбрать только те строки, где место равно 3. Вот SQL-запрос для этой задачи:

```sql
Copy code
WITH RankedCategories AS (
  SELECT
    w.name AS warehouse_name,
    i.category AS item_category,
    SUM(wi.price) AS total_price,
    ROW_NUMBER() OVER(PARTITION BY w.name, i.category ORDER BY SUM(wi.price) DESC) AS category_rank
  FROM
    warehouse w
    JOIN warehouse_item wi ON w.id = wi.warehouse_id
    JOIN item i ON wi.item_id = i.id
  GROUP BY
    w.name, i.category
)
SELECT
  warehouse_name,
  item_category,
  total_price
FROM
  RankedCategories
WHERE
  category_rank = 3;
```

Этот запрос выполняет следующие действия:

Создает временную таблицу RankedCategories, в которой рассчитывается общая стоимость товаров каждой категории на каждом складе и присваивается место категории на складе в зависимости от общей стоимости (сортировка по убыванию).
Затем основной запрос выбирает строки, где место равно 3, что соответствует категории товара с третьей по величине общей стоимостью на складе.
Таким образом, результатом запроса будет список складов, категорий и общей стоимости товаров для категорий, которые занимают третье место по стоимости на каждом складе.

SELECT
    w.name AS warehouse_name,
    i.category_name AS item_category,
    SUM(wi.price) AS total_price
FROM
    warehouse w
JOIN
    warehouse_item wi ON w.id = wi.warehouse_id
JOIN
    item i ON wi.item_id = i.id
WHERE
    (
        SELECT COUNT(DISTINCT i2.category_name)
        FROM warehouse_item wi2
        JOIN item i2 ON wi2.item_id = i2.id
        WHERE w.id = wi2.warehouse_id AND SUM(wi2.price) >= SUM(wi.price)
    ) = 3
GROUP BY
    w.name, i.category_name;



-------------------------------



Для реализации запроса с использованием Spring Data JPA и JpaRepository, вам необходимо сначала связать сущности в вашем Java-приложении с помощью аннотаций JPA. В предположении, что у вас есть сущности Warehouse, Item и WarehouseItem, которые соответствуют таблицам в базе данных, вы можете определить их следующим образом:

```java
@Entity
@Table(name = "warehouse")
public class Warehouse {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    // Геттеры и сеттеры
}

@Entity
@Table(name = "item")
public class Item {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String category;

    // Геттеры и сеттеры
}

@Entity
@Table(name = "warehouse_item")
public class WarehouseItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "warehouse_id")
    private Warehouse warehouse;

    @ManyToOne
    @JoinColumn(name = "item_id")
    private Item item;

    private BigDecimal price;

    // Геттеры и сеттеры
}
```

Затем вы можете создать интерфейс репозитория (JpaRepository) для сущности WarehouseItem, чтобы выполнять запросы к базе данных. В интерфейсе репозитория вы можете определить метод для выполнения вашего запроса. Вот как это может выглядеть:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import java.math.BigDecimal;
import java.util.List;

public interface WarehouseItemRepository extends JpaRepository<WarehouseItem, Long> {

    @Query("SELECT w.name AS warehouseName, i.category AS itemCategory, " +
           "SUM(wi.price) AS totalPrice " +
           "FROM WarehouseItem wi " +
           "JOIN wi.warehouse w " +
           "JOIN wi.item i " +
           "GROUP BY w.name, i.category " +
           "ORDER BY w.name, SUM(wi.price) DESC")
    List<Object[]> findCategoryWithThirdHighestTotalPrice();
}
```

Здесь используется аннотация `@Query`, чтобы определить SQL-запрос, а также алиасы для выбранных столбцов. Метод `findCategoryWithThirdHighestTotalPrice` будет выполнять ваш запрос.

Используя этот репозиторий в вашем сервисе или контроллере, вы сможете получить результаты запроса:

```java
@Service
public class WarehouseItemService {

    private final WarehouseItemRepository warehouseItemRepository;

    @Autowired
    public WarehouseItemService(WarehouseItemRepository warehouseItemRepository) {
        this.warehouseItemRepository = warehouseItemRepository;
    }

    public List<Object[]> getCategoryWithThirdHighestTotalPrice() {
        return warehouseItemRepository.findCategoryWithThirdHighestTotalPrice();
    }
}
```

Теперь вы можете вызвать `getCategoryWithThirdHighestTotalPrice` в вашем контроллере или другом месте вашего приложения, чтобы получить результаты запроса.


###
Для сжатия строки "ABBBCDDEEEE" в "A3BC2D4E" на Java, вы можете использовать следующий код:

```java
public class StringCompression {
    public static String compress(String input) {
        if (input == null || input.isEmpty()) {
            return input;
        }

        StringBuilder compressed = new StringBuilder();
        char currentChar = input.charAt(0);
        int count = 1;

        for (int i = 1; i < input.length(); i++) {
            char nextChar = input.charAt(i);

            if (nextChar == currentChar) {
                count++;
            } else {
                compressed.append(currentChar);
                if (count > 1) {
                    compressed.append(count);
                }
                currentChar = nextChar;
                count = 1;
            }
        }

        compressed.append(currentChar);
        if (count > 1) {
            compressed.append(count);
        }

        return compressed.toString();
    }

    public static void main(String[] args) {
        String inputString = "ABBBCDDEEEE";
        String compressedString = compress(inputString);
        System.out.println(compressedString);
    }
}
```

Этот код создает сжатую строку "A3BC2D4E", как вы ожидали, когда вы вызываете метод `compress` для входной строки "ABBBCDDEEEE".


###

