###
JFrog Nexus - это мощная система управления артефактами, которая позволяет хранить и управлять артефактами, такими как библиотеки, зависимости, контейнеры Docker и другие компоненты, используемые в разработке и CI/CD процессах. Nexus имеет несколько разновидностей, включая Nexus Repository OSS (открытая версия, бесплатная), Nexus Repository Pro (платная версия с дополнительными функциями и поддержкой) и другие.

Основные возможности JFrog Nexus включают:

1. Хранение артефактов: Nexus позволяет хранить различные типы артефактов, такие как JAR-файлы, WAR-файлы, Docker-образы, NPM-пакеты, и многое другое.

2. Проксирование удаленных репозиториев: Вы можете настроить Nexus для проксирования удаленных репозиториев, таких как Maven Central, JCenter, Docker Hub и другие. Это позволяет ускорить скачивание зависимостей и снизить нагрузку на общедоступные репозитории.

3. Управление зависимостями: Nexus обеспечивает управление зависимостями между артефактами и контроль версий.

4. Безопасность и аутентификация: Вы можете настроить правила доступа и аутентификации для обеспечения безопасности ваших артефактов.

5. Интеграция с CI/CD: Nexus интегрируется с популярными инструментами CI/CD, такими как Jenkins, TeamCity и другие.

6. Поддержка различных форматов: Nexus поддерживает различные форматы артефактов, такие как Maven, Gradle, NPM, Docker и другие.

7. Удобное управление артефактами: Интуитивный веб-интерфейс позволяет легко загружать, скачивать и управлять артефактами.

Чтобы начать использовать JFrog Nexus, вам необходимо установить и настроить его в соответствии с вашими потребностями. Вам также может потребоваться интегрировать Nexus с вашей системой сборки и CI/CD процессами.

JFrog Nexus популярен среди разработчиков и DevOps-инженеров благодаря своей надежности и богатым функциональным возможностям для управления артефактами и зависимостями.


###
Artifactory - это мощная система управления артефактами, предоставляемая компанией JFrog. Она позволяет организациям хранить, управлять и развертывать различные типы артефактов, такие как библиотеки, зависимости, Docker-образы, NPM-пакеты, RPM-пакеты и другие компоненты разработки программного обеспечения. Artifactory также интегрируется с популярными инструментами CI/CD и системами сборки.

Основные возможности Artifactory включают:

1. Хранение артефактов: Artifactory предоставляет место для хранения разнообразных артефактов, поддерживая различные форматы и типы компонентов.

2. Проксирование удаленных репозиториев: Artifactory может проксировать удаленные репозитории, такие как Maven Central, JCenter, Docker Hub и другие. Это позволяет ускорить загрузку зависимостей и обеспечить доступность даже в условиях отсутствия интернета.

3. Управление зависимостями: Artifactory позволяет управлять зависимостями и контролировать версии артефактов.

4. Безопасность и аутентификация: Вы можете настроить правила доступа и аутентификации для обеспечения безопасности ваших артефактов.

5. Интеграция с CI/CD: Artifactory интегрируется с популярными системами сборки, такими как Jenkins, Travis CI, GitLab CI/CD и другими.

6. Поддержка различных форматов: Artifactory поддерживает разные форматы артефактов, включая Maven, Gradle, NPM, Docker, RPM и другие.

7. Удобное управление артефактами: Веб-интерфейс Artifactory обеспечивает удобный доступ к артефактам, возможность поиска и просмотра метаданных.

Artifactory позволяет организациям улучшить управление своими артефактами, обеспечивая надежность и доступность. Она подходит для команд разработки, DevOps и CI/CD, и широко используется в индустрии разработки программного обеспечения. Artifactory предоставляет как бесплатную версию (Artifactory OSS), так и коммерческие версии с дополнительными функциональными возможностями и поддержкой.


###
//что выведет данный код
Stream.of("b", "a", "d", "c")
        .map(val -> val + 1)
        .peek(System.out::println)
        .forEach(System.out::println);// b1, b1, a1, a1, и тд





//что выведет данный код
Stream.of("b", "a", "d", "c")
        .map(val -> val + 1)
        .peek(System.out::println) b1, a1, d1, c1, a1, b1, c1, d1
        .sorted()
        .forEach(System.out::println);






//как отработает следующий код
List<String> list = Stream.of("b", "a", "d", "c")
        .map(val -> val + "t")
        .toList();

list.add("w");
System.out.println(list.size());






@RestController
  public class MyController {
    int count = 0;

    @GetMapping("/getAdd")
    public void getAdd() {
        count++;
    }

    @GetMapping("/get")
     public int get() {
        return count;
    }
}


//В данном коде значение переменной `count` в классе `MyController` будет всегда равно нулю. Каждый раз, когда выполняется запрос к методу `getAdd()` через путь `/getAdd`, инкрементация переменной `count` происходит только в пределах одного вызова метода. Когда метод завершается, значение `count` не сохраняется между запросами. Это означает, что при каждом новом запросе к `/getAdd`, переменная `count` будет снова установлена в 0, и при запросе к `/get` будет возвращено значение 0.

Чтобы сохранить значение `count` между запросами, вам нужно использовать способ хранения состояния между запросами, такой как хранение значения в базе данных, внешнем файле, кеше или сессии.





@Service
public class ServiceTest{
  @Transactional
  public void test1{
      test2();
  }

  @Transactional(propagation = Propagation.REQUIRES_NEW)
  public void test2(){
  }
}





@Component
@Scope(name = "prototype", description = "")
public class TestBeanPrototype {

}

@Service
public class TestBean {


    private final TestBeanPrototype testBeanPrototype;
    
    @Lookup
    public TestBeanPrototype getTestBeanPrototype() {
        return null;
    }

}

@SpringBootApplication
public class Main {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Main.class, args);
        var singletonBeanFirst = context.getBean(TestBean.class);
        var prototypeBeanFirst = singletonBeanFirst.getTestBeanPrototype();

        var singletonBeanSecond = context.getBean(TestBean.class);
        var prototypeBeanSecond = singletonBeanSecond.getTestBeanPrototype();

        System.out.println(prototypeBeanFirst.equals(prototypeBeanSecond));
    }

} 





    person
    id      name        pos_id
    1       Владимир    1
    2       Иван        3
    3       Александр   2

    positions
    id      title
    1       Дизайнер
    2       Тестировщик
    3       Разработчик

    получить результат в виде таблицы
    id      name        pos_title
    1       Владимир    Дизайнер
    2       Иван        Разработчик
    3       Александр   Тестировщик
 
 SELECT (pers.id, pers.name, pos.title AS pos_title) FROM
 person AS pers
 JOIN positions AS pos
 ON pers.pos_id=pos.id;
 
 
 
 
     category
    id    name
    1     сладкое
    2     соленое
    3     фрукты

    product
    id    category_id    price    name
    1     1              50       печенье
    2     1              75       мармелад
    3     1              100      конфеты
    4     1              125      шоколад
    5     2              150      арахис
    6     2              75       чипсы
    7     2              150      кальмары
    8     3              175      лимон
    9     3              200      гранат

    выбрать все продукты в которых категория такая же как и у конфет и цена меньше 100
    





transactions
        date                    cash_flow
        2023-01-01      -1000
        2023-01-02      -100
        2023-01-03       50

получить нарастающий итог для денежного потока каждый день таким образом, чтобы в конечном итоге получилась таблица
        date                    cash_flow                   cumulative_cf
        2023-01-01          -1000                       -1000
        2023-01-02          -100                        -1100
        2023-01-03           50                         -1050
        



------
Давайте рассмотрим ваши вопросы поочередно:

1. **Первый код**:
    - `Stream.of("b", "a", "d", "c")` создает поток из четырех элементов.
    - `map(val -> val + 1)` конкатенирует каждый элемент строки с "1".
    - `peek(System.out::println)` выводит каждый элемент потока, поэтому будет выведено "b1", "a1", "d1", "c1".
    - `forEach(System.out::println)` снова выводит каждый элемент потока, поэтому элементы будут выведены вдвойне.
    
   Вывод:
   ```
   b1
   b1
   a1
   a1
   d1
   d1
   c1
   c1
   ```

2. **Второй код**:
    - Тот же код, но после `peek(System.out::println)` следует операция `sorted()`, которая сортирует элементы по алфавиту. Поэтому после сортировки будут выведены в порядке "a1", "b1", "c1", "d1".
    - Затем `forEach(System.out::println)` выводит отсортированные элементы.

   Вывод:
   ```
   a1
   b1
   c1
   d1
   ```

3. **Третий код**:
    - `toList()` преобразует поток в список, и этот список неизменяем.
    - `list.add("w")` попытка добавить элемент в неизменяемый список вызовет `UnsupportedOperationException`.
    - `System.out.println(list.size())` не выполнится из-за предыдущей ошибки.

4. **Контроллер и сервис**:
    - Контроллер `MyController` имеет два метода:
      - `/getAdd` инкрементирует счетчик `count`.
      - `/get` возвращает текущее значение `count`.
    - Сервис `ServiceTest` содержит два метода, `test1` и `test2`, оба помечены как транзакционные, но `test2` имеет отдельную транзакцию (REQUIRES_NEW).
    - `@Transactional(propagation = Propagation.REQUIRES_NEW)` в `test2` означает, что он будет выполняться в собственной транзакции и независимо от родительской транзакции, если она существует.

5. **Spring Beans**:
    - В вашем коде `TestBean` и `TestBeanPrototype` сконфигурированы с использованием аннотаций `@Component` и `@Scope`. `TestBean` имеет метод `getTestBeanPrototype`, который аннотирован `@Lookup`, и должен возвращать новый экземпляр `TestBeanPrototype` при каждом вызове.
    - В методе `main` создается контекст приложения, и вызываются два метода `getTestBeanPrototype` на одном экземпляре `TestBean`, и затем проверяется, равны ли полученные экземпляры. Они должны быть разными, так как `@Scope("prototype")` указывает, что каждый вызов должен создавать новый экземпляр.

6. **SQL-запросы**:
    - Для запросов к базе данных вы представили две таблицы `person` и `positions`. Для получения результата в виде таблицы с использованием SQL, вы можете воспользоваться запросом с объединением (JOIN). Здесь представлена SQL-команда, которая соединяет две таблицы:
    ```sql
    SELECT pers.id, pers.name, pos.title AS pos_title
    FROM person AS pers
    JOIN positions AS pos
    ON pers.pos_id = pos.id;
    ```
    Этот запрос вернет таблицу с столбцами `id`, `name`, и `pos_title`, которая соответствует вашему требованию.

7. **SQL-запрос для продуктов**:
    - Вы хотите выбрать все продукты, у которых категория такая же, как у конфет, и цена меньше 100. Вы можете использовать SQL-запрос с фильтрацией:
    ```sql
    SELECT p.*
    FROM product p
    JOIN category c ON p.category_id = c.id
    WHERE c.name = 'конфеты' AND p.price < 100;
    ```
    Этот запрос вернет все продукты с категорией "конфеты" и ценой менее 100.

8. **Вычисление кумулятивного денежного потока**:
    - Для вычисления кумулятивного денежного потока (cumulative cash flow) вы может



###

